Problem Statement:

Find the middle node of a singly linked list using the slow and fast pointer approach.

Approach:

1. Use two pointers, slow and fast.
2. Start both pointers at the head of the list.
3. Move slow forward by one node and fast forward by two nodes in each step.
4. When fast reaches the end of the list, slow will be positioned at the middle node.

Dry run:

linked list: 1 -> 2 -> 3 -> 4 -> 5

Initialize:

slow = head (1)
fast = head (1)

Step 1: First iteration of while loop
fast and fast.next exist (fast = 1, fast.next = 2) → continue
Move pointers:
slow = slow.next → 2
fast = fast.next.next → 3
State now: slow = 2, fast = 3

Step 2: Second iteration
fast and fast.next exist (fast = 3, fast.next = 4) → continue
Move pointers:
slow = slow.next → 3
fast = fast.next.next → 5
State now: slow = 3, fast = 5

Step 3: Third iteration
fast and fast.next? (fast = 5, fast.next = null) → condition fails
Exit loop

Step 4: Return
return slow → 3

Result: The middle node is 3.