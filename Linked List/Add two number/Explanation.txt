Problem Statement:

You are given two non-empty linked lists representing two non-negative integers. 
The digits are stored in reverse order, and each of their nodes contains a single digit. 
Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Approach:

1. Create a dummy node ans — acts as the starting point of the result list.
(ansHead keeps track of the real head for final return.)
2. Initialize carry = 0 — to store overflow from each addition.
3. Traverse both linked lists (l1, l2) while either list has nodes or a carry remains.
4. At each step:
Get values:
val1 = l1 ? l1.val : 0
val2 = l2 ? l2.val : 0
Calculate sum = val1 + val2 + carry
Update carry = Math.floor(sum / 10)
Get current digit: digit = sum % 10
Create a new node with digit and attach to result list.
5. Move both pointers (l1, l2) to the next nodes.
6. Return the list starting from ansHead.next (skip dummy node).

Dry run:

Input:
l1 = [2 → 4 → 3]
l2 = [5 → 6 → 4] 
Represents numbers: 342 + 465 = 807


Step 0:

carry = 0
ans = new ListNode()  // dummy node
ansHead = ans

Step 1:

l1.val = 2, l2.val = 5
sum = 2 + 5 + 0 = 7
carry = 0
digit = 7
→ create node(7)
ans.next = node(7)
Move l1 → 4, l2 → 6
Current result: [7]

Step 2:

l1.val = 4, l2.val = 6
sum = 4 + 6 + 0 = 10
carry = 1
digit = 0
→ create node(0)
ans.next = node(0)
Move l1 → 3, l2 → 4
Current result: [7 → 0]

Step 3:

l1.val = 3, l2.val = 4
sum = 3 + 4 + 1 = 8
carry = 0
digit = 8
→ create node(8)
Move l1 = null, l2 = null
Current result: [7 → 0 → 8]

Step 4:

Loop ends (no l1, l2, carry = 0)

Output:
[7 → 0 → 8] Which represents 807 