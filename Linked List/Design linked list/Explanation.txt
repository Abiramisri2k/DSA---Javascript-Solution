Linked List:

A Linked List is a linear data structure where elements, called nodes, are connected through pointers. Each node typically contains:

* Value → the actual data stored
* Reference (pointer) → a link to the next node (and in some cases, also the previous node)

Types of Linked Lists:

1. Singly Linked List

Each node has two parts:

  * value → stores the data
  * next → pointer to the next node
* Traversal is possible only in one direction (forward).
* Structure: [value | next] -> [value | next] -> [value | null]

2. Doubly Linked List

Each node contains:

  * value → the data
  * next → pointer to the next node
  * prev → pointer to the previous node
* Allows movement in both directions (forward and backward).
* Structure: null <- [prev | value | next] <-> [prev | value | next] -> null

Key Terminologies:

* Head → the first node in the list, marking the entry point, and pointing to the next node.
* Tail → the last node in the list, which points to `null` since there is no node after it.

Representation:

A linked list is generally represented starting from its head node, which serves as the reference to access the entire list.


Problem Statement:

Design and implement a custom singly linked list class with the following operations:

Operations:

1. get(index) → Returns the value of the node at the given (0-based) index. If the index is out of range, return -1.
2. addAtHead(val) → Inserts a new node with the given value at the start of the list.
3. addAtTail(val) → Adds a new node with the given value to the end of the list.
4. addAtIndex(index, val) → Inserts a new node with the given value before the node at the specified index.
5. deleteAtIndex(index) → Removes the node at the specified index, if it exists.

Approach:

1. Create a custom Node class that stores a val (data) and a next (pointer to the next node).
2. Keep a head pointer to reference the first node and a size counter to track the current length of the list.
3. For every operation, first validate the index to avoid out-of-bound errors.
4. Use a loop to traverse the list until the desired index or position is reached.

Dry run:

Input sequence:
let list = new MyLinkedList();
list.addAtHead(1);      // [1]
list.addAtTail(3);      // [1 -> 3]
list.addAtIndex(1, 2);  // [1 -> 2 -> 3]
list.get(1) // 2
list.deleteAtIndex(1);  // [1 -> 3]
list.get(1) // 3


Step by Step:

* addAtHead(1)
New node = 1
Head → 1
Size = 1
List: [1]

* addAtTail(3)

Traverse to end → after 1, add 3
List: [1 -> 3]
Size = 2

* addAtIndex(1, 2)

Traverse to index-1 (node 1)
New node = 2 → link 2.next = 3
Update 1.next = 2
List: [1 -> 2 -> 3]
Size = 3

* get(1)

Traverse: start at head (1) → move 1 step → reach 2
Output: 2

* deleteAtIndex(1)

Traverse to index-1 (node 1)
1.next = 1.next.next → 1.next = 3
Node 2 removed
List: [1 -> 3]
Size = 2

* get(1)

Traverse: start at head (1) → move 1 step → reach 3
Output: 3