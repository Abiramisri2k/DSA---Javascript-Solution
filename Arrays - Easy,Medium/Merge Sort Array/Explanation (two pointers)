Problem statement:

You are given two integer arrays, nums1 and nums2, both sorted in non-decreasing order. Along with these, you are given two integers m and n, where:
 --> m is the number of valid elements in nums1.
 --> n is the number of elements in nums2.
Your task is to merge nums2 into nums1 so that nums1 becomes a single sorted array in non-decreasing order.
nums1 has a total size of m + n.
The first m positions contain the actual elements to be merged.
The last n positions are placeholders (set to 0) and should be ignored.
nums2 has exactly n elements.
The merged result must be stored directly in nums1 (do not return a new array).

Approach:

* Copy the first `m` elements of `nums1` into a temporary array `nums1Copy`.
* Initialize two pointers:
  --> `p1 = 0` → tracks position in `nums1Copy`.
  --> `p2 = 0` → tracks position in `nums2`.
* Iterate `i` from `0` to `m + n - 1` to fill `nums1`.
* At each step:
  --> If `p2` is exhausted, or (`p1` not exhausted && `nums1Copy[p1] <= nums2[p2]`), take `nums1Copy[p1]`
      and   increment `p1`.
  --> Otherwise, take `nums2[p2]` and increment `p2`.
* Continue until all positions of `nums1` are filled with sorted elements.
* Time complexity: `O(m + n)`.
* Space complexity: `O(m)` (extra space for `nums1Copy`).

Dry run:

Input:
nums1 = [2,5,6,0,0,0], m = 3
nums2 = [1,2,3], n = 3

Step 1: Copy first m elements

let nums1Copy = nums1.slice(0, m)  // → [2,5,6]
let p1 = 0;
let p2 = 0;


So:

* `nums1Copy = [2,5,6]`
* `nums2 = [1,2,3]`
* `nums1 = [2,5,6,0,0,0]` (we will overwrite this)

Step 2: Loop through `i = 0 → 5`

i = 0
* Condition check: `p2 >= n (0>=3? false)`
* `(p1 < m && nums1Copy[p1] < nums2[p2]) → (0<3 && 2 < 1? false)`
* Else branch → `nums1[0] = nums2[0] = 1`
* `p2 = 1`
* nums1 = `[1,5,6,0,0,0]`

i = 1
* `p2>=3? false`
* `(p1<3 && 2 < 2? false)`
* Else branch → `nums1[1] = nums2[1] = 2`
* `p2 = 2`
* nums1 = `[1,2,6,0,0,0]`

i = 2
* `p2>=3? false`
* `(p1<3 && 2 < 3? true)` 
* nums1[2] = nums1Copy[0] = 2
* `p1 = 1`
* nums1 = `[1,2,2,0,0,0]`

i = 3
* `p2>=3? false`
* `(p1<3 && 5 < 3? false)`
* Else branch → nums1[3] = nums2[2] = 3
* `p2 = 3`
* nums1 = `[1,2,2,3,0,0]`

i = 4
* `p2>=n → 3>=3? true` 
* nums1[4] = nums1Copy[1] = 5
* `p1 = 2`
* nums1 = `[1,2,2,3,5,0]`

i = 5
* `p2>=n → 3>=3? true` 
* nums1[5] = nums1Copy[2] = 6
* `p1 = 3`
* nums1 = `[1,2,2,3,5,6]`

Final Result:
nums1 = [1,2,2,3,5,6]
